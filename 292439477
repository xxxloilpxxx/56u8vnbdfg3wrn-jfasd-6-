repeat
	task.wait()
until game:IsLoaded()
local Rayfield = loadstring(game:HttpGet('https://raw.githubusercontent.com/shlexware/Rayfield/main/source'))()
local AkaliNotif = loadstring(game:HttpGet("https://raw.githubusercontent.com/Kinlei/Dynissimo/main/Scripts/AkaliNotif.lua"))();
local Notify = AkaliNotif.Notify;
local eps = {}
getgenv().eps = {}

local Window = Rayfield:CreateWindow({
	Name = "mopsHub - Phantom Forces",
	LoadingTitle = "mopsHub - Phantom Forces",
	LoadingSubtitle = "by ShyFlooo",
	ConfigurationSaving = {
		Enabled = true,
		FolderName = "mopsHubConfig", -- Create a custom folder for your hub/game
		FileName = "mopshub_phantomforces"
	}, 
	KeySystem = false, -- Set this to true to use our key system
	KeySettings = {
		Title = "mopsHub",
		Subtitle = "Key System",
		Note = "Join the discord (discord.gg/sirius)",
		FileName = "SiriusKey",
		SaveKey = true,
		GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
		Key = "lol"
	}
})

local Tab1 = Window:CreateTab("Weapon")
local Tab2 = Window:CreateTab("Visual")
local Tab3 = Window:CreateTab("Character")
local Tab4 = Window:CreateTab("Credits")

Tab4:CreateSection("Developers")
local Paragraph = Tab4:CreateParagraph({Title = "Main Developer", Content = "ShyFlooo"})

--Infinite Jump
getgenv()._infinitejump = false
local _infjump = Tab3:CreateToggle({
	Name = "Infinite Jump",
	Flag = "_infjump",
	Callback = function(Value)
		getgenv()._infinitejump = Value
	end,
})
local Player = game:GetService'Players'.LocalPlayer;
local UIS = game:GetService'UserInputService';
 
_G.JumpHeight = 50;
 
function Action(Object, Function) if Object ~= nil then Function(Object); end end
 
UIS.InputBegan:connect(function(UserInput)
    if UserInput.UserInputType == Enum.UserInputType.Keyboard and UserInput.KeyCode == Enum.KeyCode.Space then
		if not getgenv()._infinitejump then return end
        Action(Player.Character.Humanoid, function(self)
            if self:GetState() == Enum.HumanoidStateType.Jumping or self:GetState() == Enum.HumanoidStateType.Freefall then
                Action(self.Parent.HumanoidRootPart, function(self)
                    self.Velocity = Vector3.new(0, _G.JumpHeight, 0);
                end)
            end
        end)
    end
end)

--ESP
Tab2:CreateSection("ESP")
getgenv()._esp = false
local _esp = Tab2:CreateButton({
	Name = "ESP",
	Flag = "_esp",
	Callback = function(Value)
	getgenv()._esp = true
		assert(Drawing, "missing dependency: drawing\nesp disabled\nreason: your executor is not supporting the Drawing dependency. use synapse or krnl")

		-- Services
		local players = game:GetService("Players")
		local run_service = game:GetService("RunService")
		-- Localizing
		local local_player = players.LocalPlayer
		local get_children = game.GetChildren
		local find_first_child = game.FindFirstChild
		local new_drawing = Drawing.new
		local camera = workspace.CurrentCamera or game:GetService("Workspace").CurrentCamera

		-- Setup
		local rootPart = "Head"
		local objects_folder: Folder = game:GetService("Workspace").Players
		local coreGui = game:GetService("CoreGui")
		-- main
		local object_ID = {}
		local eps = {}

		local function Setup()
		if not getgenv()._esp then return end
			for _, team in pairs(objects_folder:GetChildren()) do
				for _, object in pairs(get_children(team)) do
					local id = object:GetDebugId()
					if not table.find(object_ID, id) then
						table.insert(object_ID, id)
						eps[id] = {
							esp_object = object,
							text_esp = new_drawing("Text", true),
							highlight = Instance.new("Highlight", coreGui),
						}
						eps[id].text_esp.Center = true
						eps[id].text_esp.Outline = true
						eps[id].text_esp.Font = 1
						eps[id].text_esp.Size = 14
						eps[id].highlight.Adornee = eps[id].esp_object
						eps[id].highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
						eps[id].highlight.Enabled = true
						eps[id].highlight.FillTransparency = true
					end
				end
			end
		end

		Setup()
		shared.max_distance = math.huge
		shared.object_esp_enabled = true
		run_service.RenderStepped:Connect(function()
			if not shared.object_esp_enabled and not getgenv()._esp then
				return
			end
			for _, value in pairs(eps) do
				if
					shared.object_esp_enabled
					and find_first_child(value.esp_object, rootPart)
					and value.esp_object.Parent.Name ~= local_player.TeamColor.Name
				then
					local name = value.esp_object.Name
					local vec3_position = find_first_child(value.esp_object, rootPart).Position
					local screen_position, on_screen = camera:WorldToScreenPoint(vec3_position)
					local distant_from_character = local_player:DistanceFromCharacter(vec3_position)
					if on_screen and math.round(distant_from_character) <= shared.max_distance then
						value.text_esp.Position = Vector2.new(
							screen_position.X,
							screen_position.Y + math.clamp(distant_from_character / 10, 10, 30) - 10
						)
						value.text_esp.Color = Color3.fromHSV(math.clamp(distant_from_character / 5, 0, 125) / 255, 0.75, 1)
						value.text_esp.Text = name .. "[" .. math.round(distant_from_character) .. "]"
						value.text_esp.Size = math.clamp(30 - distant_from_character / 10, 16, 30)
						value.text_esp.Transparency = math.clamp((500 - distant_from_character) / 200, 0.2, 1)
						value.text_esp.Visible = true
						value.highlight.FillColor =
							Color3.fromHSV(math.clamp(distant_from_character / 5, 0, 125) / 255, 0.75, 1)
						value.highlight.FillTransparency = math.clamp((500 - distant_from_character) / 200, 0.2, 1)

						value.highlight.Enabled = true
					else
						value.text_esp.Visible = false
						value.highlight.Enabled = false
					end
				else
					value.text_esp.Visible = false
					value.highlight.Enabled = false
				end
			end
		end)
		objects_folder.DescendantAdded:Connect(function()
		if not getgenv()._esp then return end
			Setup()
		end)
		objects_folder.DescendantRemoving:Connect(function(child)
		if not getgenv()._esp then return end
			local id = child:GetDebugId()
			if table.find(object_ID, id) then
				eps[id].text_esp:Remove()
				eps[id].highlight:Destroy()
				eps[id].esp_object = nil
				eps[id] = nil
			end
		end)
	end,
})

--Silent Aimbot
getgenv()._hitchance = 50
getgenv()._slientaimbot = false
getgenv()._visibleCheck = false
getgenv()._hitpart = "Random"
local _slientaimbot = Tab1:CreateToggle({
	Name = "Silent Aimbot",
	Flag = "_slientaimbot",
	Callback = function(Value)
		getgenv()._slientaimbot = Value
	end,
})
--[[
local _fovvisible = Tab1:CreateToggle({
	Name = "FOV Visible",
	Flag = "_fovvisible",
	Callback = function(Value)
		getgenv()._fovvisible = Value
	end,
})]]
local _vischeck = Tab1:CreateToggle({
	Name = "Visible Check",
	Flag = "_vischeck",
	Callback = function(Value)
		getgenv()._visibleCheck = Value
	end,
})--[[
local _hitchance = Tab1:CreateSlider({
	Name = "Head Hit Chance",
	Range = {0, 100},
	Increment = 1,
	Suffix = "%",
	CurrentValue = getgenv()._hitchance,
	Flag = "_hitchance",
	Callback = function(Value)
		getgenv()._hitchance = Value
	end,
})]]
local _hitpart = Tab1:CreateDropdown({
	Name = "Hit Part",
	Flag = "_hitpart",
	Options = {"Random","Head","Torso"},
	CurrentOption = getgenv()._hitpart or "Random",
	Callback = function(Value)
		getgenv()._hitpart = Value
	end,
})
-- variables
local players = game:GetService("Players");
local localplayer = players.LocalPlayer;
local camera = workspace.CurrentCamera;
local shared = getrenv().shared;

-- modules
local physics = shared.require("physics");
local particle = shared.require("particle");
local replication = shared.require("ReplicationInterface");
local solve = debug.getupvalue(physics.timehit, 2);

-- functions
local function isVisible(position, ignore)
	if not getgenv()._slientaimbot then return end
    return #camera:GetPartsObscuringTarget({ position }, ignore) == 0;
end

local function getClosest(dir, origin, ignore)
	if not getgenv()._slientaimbot then return end
    local _angle = math.rad(fov or 180);
    local _position, _entry;

    replication.operateOnAllEntries(function(player, entry)
        local tpObject = entry and entry._thirdPersonObject;
        local character = tpObject and tpObject._character;
        if character and player.Team ~= localplayer.Team then
            local position = character[getgenv()._hitpart == "Random" and
                (math.random() < (headChance or 0.5) and "Head" or "Torso") or
                (getgenv()._hitpart or "Head")].Position;

            if not (getgenv()._visibleCheck and not isVisible(position, ignore)) then
                local product = dir.Unit:Dot((position - origin).Unit);
                local angle = math.acos(product);
                if angle < _angle then
                    _angle = angle;
                    _position = position;
                    _entry = entry;
                end
            end
        end
    end);

    return _position, _entry;
end

local function trajectory(dir, velocity, accel, speed)
	if not getgenv()._slientaimbot then return end	
    local t1, t2, t3, t4 = solve(
        accel:Dot(accel) * 0.25,
        accel:Dot(velocity),
        accel:Dot(dir) + velocity:Dot(velocity) - speed^2,
        dir:Dot(velocity) * 2,
        dir:Dot(dir));

    local time = (t1>0 and t1) or (t2>0 and t2) or (t3>0 and t3) or t4;
    local bullet = 0.5*accel*time + dir/time + velocity;
    return bullet, time;
end

-- hooks
local old;
old = hookfunction(particle.new, function(args)
	if not getgenv()._slientaimbot then return end
    if debug.info(2, "n") == "fireRound" then
        local position, entry = getClosest(args.velocity, args.visualorigin, args.physicsignore);
        if position and entry then
            local index = table.find(debug.getstack(2), args.velocity);

            args.velocity = trajectory(
                position - args.visualorigin,
                entry._velspring._p0,
                -args.acceleration,
                args.velocity.Magnitude);

            debug.setstack(2, index, args.velocity);
        end
    end
    return old(args);
end);
--[[
local circle = Drawing.new("Circle")
circle.Thickness = 2
circle.NumSides = 50
circle.Radius = 180
circle.Filled = false
circle.Transparency = 1
circle.Color = Color3.new(1, 0, 0)
local mouse = game.Players.LocalPlayer:GetMouse()
game:GetService("RunService").RenderStepped:Connect(function()
    if circle then
		circle.Visible = getgenv()._fovvisible
        circle.Position = Vector2.new(mouse.X, mouse.Y)
        circle.Radius = getgenv()._fov
    end
end)]]
